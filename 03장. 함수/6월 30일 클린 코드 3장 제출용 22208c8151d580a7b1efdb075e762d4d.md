# 6월 30일 클린 코드 3장 제출용

### 감상평

제3장 함수는 읽기 쉽고 이해하기 쉬운 함수가 어떤 함수 인지, 의도를 분명히 표현하는 함수의 구현방법, 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있는 방법등을 제시하고 있다.

함수 챕터를 읽고 나서 갑자기 생각이 난게 지금 준비하고 있는 정보처리기사에 나오는 개념으로 정리 할 수 있어 시험이나 스터디에 도움이 될것 같아서 시험용 키워드와 클린 코드와 연결한 내용을 정리하고 클린 코드에서 말하는 좋은 함수가 무엇인지 정리 하려고 한다.

### 함수(Function) vs 메소드(Method)

**기본 개념**

| 구분 | 함수(Function)  | 메소드(Method)  |
| --- | --- | --- |
| 정의 | 독립적으로 존재하는 코드 블록  | 객체(또는 클래스)에 소속된 함수  |
| 소속  | 없음(전역 또는 모듈 단위)  | 어떤 객체나 클래스의 일부 |
| 호출 방식  |  함수 이름으로 호출  | 객체.메소드() 형태로 호출  |
| 예시 | JavaScript의 function foo() | Java의 object.method() |

쉽게 말하자면 메소드는 함수지만 객체에 붙어있으면 메소드이다.
자바에서 모든 함수는 메소드(독립 함수 없음)
자바스크립트에는 함수도 있고 메소드도 있다. 

### 클린 코드에서 말하는 ‘함수’는 무엇인가?

프로그래밍 언어 상관없이 “**동작을 수행하는 코드 블록**“을 의미
Java의 Method나 JS의 Function이나 포괄적으로 함수(Function)라고 부르고 있다고 한다.

### **”응집도가 높을 수록, 결합도가 낮을 수록 이상적인 모듈화이다.“**

필기 시험 준비할 때 중요하다고 외웠던 내용인데 클린코드에서는 실제로 어떻게 해야하는지 함수 챕터에서 알려주는것이고 함수단위에서 응집도와 결합도를 신경쓰는게 실무나 시험이나 중요한 부분! 

** 클린 코드는 함수 단위로 “모듈화“ 실천 **

### 모듈화

모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화 함으로서, 시스템의 수정 및 재사용, 유지관리를 용이하게 하는 기법이다.

클린 코드와 연결해서 보면

- 함수는 ”작고, 한 가지 일만 하게“ 만들어야 한다.
- 함수/클래스를 작게 나누는 것이 곧 모듈화!
- 중복 제거 = 재사용 가능한 모듈화

모듈화의 장점은 유지 보수성/재사용/독립성 향상

### 응집도

응집도는 모듈(함수)내 구성 요소들이 관계를 맺고 있는 정도로 표현되며, 응집도가 높을 수록 그 모듈(함수)이 하나의 목적에 집중한다는 뜻이다.

클린 코드와 연결해서 보면

- 함수는 한가지 일만 하라 → 응집도를 높이는 원칙
- 같은 책임을 가지는 함수끼리 묶기 → 클래스도 고응집

응집도가 높아지면 이해하기 쉽고 수정범위가 명확해진다.

### 결합도

결합도는 모듈(함수)들이 서로 얼마나 강하게 의존하고 있는지를 나타내며 결합도가 높을 수록 한쪽 변경 시 다른 쪽도 영향을 받는다.

클린 코드와 연결해서 보면

- 의존성 낮추기 → 결합도 낮추기
- 인터페이스나 추상화로 직접 연결을 피함, 클래스간 직접 참견 대신 인터페이스 사용 권장

낮은 결합도의 모듈(함수)은 모듈(함수)간 영향이 적고 변경에 강한 구조를 갖게 된다.

### 의존성

의존성은 A모듈(함수)이 B모듈(함수)에 기능이나 자료구조를 의존하는 정도를 나타내며

클린 코드와 연결해서 보면

- 변경에 유연한 코드 = 의존성 제어
- 클린 코드에서는 다음을 권장 : 의존성 감추기, 의존성 주입, 인터페이스/추상화 활용, 직접 생성 대신 팩토리/컨테이너 사용

의존성은 있어야 하지만, 관리되고 통제되어야 한다 → ”낮은 결합고, 높은 응집도“를 위한 수단

### 전체 연결 요약도

![IMG_0500.jpeg](IMG_0500.jpeg)

** 클린 코드에서 함수나 객체를 작게 나누고 의존성을 제어하는 원칙은 이를 실천하는 구체적인 방식이다 **

### 클린 코드가 말하는 좋은 함수는?

좋은 함수란 하나의 명확한 책임을 가지고 내부 기능은 서로 밀접하게 관련되며(높은 응집도), 외부와는 가능한 독립적으로 동작하는(낮은 결합도) 구조를 말한다.

→ 작고, 한 가지 일만 하며, 이름만 봐도 무슨 일을 하는지 알 수 있고 부작용이 없어야 한다!

### 생각해보자

1. **결합도는 낮을 수록 좋은가?**

** 결합도가 지나치게 낮으면 가독성과 디버깅 효율이 떨어지기 때문에, 결합도를 낮추는 목적이 아니라 적절히 관리 하는게 핵심! **

**SOLID(객체지향 설계 원칙**) : 로버트 마틴이 2000년대 초반에 명명한 것을 마이클 페더스가 두문자어 기억술로 소개한 것으로 객체지향설계에서 지켜야할 5개의 소프트웨어 개발 원칙이다.

| **약자, 원칙명** | **정의** | **실무 예시** |
| --- | --- | --- |
| S - SRP
**단일 책임 원칙
(Single responsibility principle)**  | 한 클래스는 하나의 책임(기능)만 가지도록 설계한다 . | UserService는 사용자 관리만, EmailService는 메일 전송만 담당 |
| O - OCP
**개방-폐쇄 원칙
(Open/closed principle)** | 새로운 변경 사항이 발생 했을 때 쉽게 확장 가능해야 하나 객체를 직접적으로 수정하지는 못하게 해야 한다. | 인터페이스 도입해서 새 구현만 추가하고 기존 코드는 건드리지 않는다. |
| L - LSP
**리스코프 치환 원칙
 (Liskov substitution principle)** |  ****자식 클래스는 부모 클래스 대신 사용 가능 해야 한다. 자식 클래스를 써도 프로그램이 정상적으로 동작 해야 한다. (다형성) | Brid를 상속한 Penguin이 fly()를 오버라이드 하면 위반됨 |
| I - ISP
**인터페이스 분리 원칙 
(Interface segregation principle)** | 인터페이스를 각각의 목적과 용도에 적합하게 잘 분리하고 클라이언트가 사용하지 않는 인터페이스에 의존하지 말아야 한다. | Printer 인터페이스 대신 Printable, Scannable로 나눔 |
| D - DIP
**의존관계 역전 원칙
(Dependency inversion principle)** | 구체화가 아닌 추상화에 의존해야 한다는 원칙으로, 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 한다. | PaymentService가 KakaoPya에 직접 의존 X → PayMethod  인터페이스를 통해 연결 |
1. **언제 함수를 쪼개지 말아야 하는가?**

| **나누는 게 좋은 경우** | **나누지 않는 게 좋은 경우** |
| --- | --- |
| 명확한 역할이 존재 할 때   | 한 덩어리로 이해하는 게 더 쉬울 때  |
| 중복 제거 또는 재사용 가능할 때  | 재사용 가능성이 전혀 없을 때  |
| 함수 이름만 봐도 역할이 명확 할 때 | 이름 짓기가 애매하고 혼란스러울 때  |
| 테스트 단위로 분리 가능한 경우  | 너무 작아져서 응집도까지 떨어질 때 |
| 복잡한 로직을 쪼갤 수 있을 때 | 로직이 간단하고 명확 할 때  |

** 함수는 작게 쪼개야 좋지만 쪼갠 결과와 오히려 이해를 방해하거나 의미가 없어지면 그건 ‘클린 코드’가 아니라 ‘과도한 분리’다. 코드는 읽는 사람 중심이다! **

### 함수 쪼갤까 말까?

문제 1

```java
public void printUserInfo(User user) {
    System.out.println("이름: " + user.getName());
    System.out.println("이메일: " + user.getEmail());
    System.out.println("가입일: " + user.getJoinDate());
}
```

문제 2

```java
function sendEmail(user) {
  if (!user.email.includes("@")) {
    throw new Error("유효하지 않은 이메일입니다.");
  }

  const subject = "가입을 환영합니다!";
  const body = `안녕하세요 ${user.name}님, 가입을 환영합니다!`;
  emailService.send(user.email, subject, body);
}
```

문제 3

```java
public void registerUser(String name, String email) {
    User user = new User(name, email);
    userRepository.save(user);
    notificationService.sendWelcomeEmail(user);
}
```

# **✅ 클린 코드의 좋은 함수 10가지 원칙 요약**

1. **작게 만들어라 (Small)**
- 함수는 짧고 더 짧아야 한다.
- 줄 수가 적을수록 좋다. 가급적 한 눈에 들어오는 길이.
- 함수 안에 if/else, while, switch 등이 있으면 그 안도 짧게 유지해야 한다.
1. **한 가지 일만 해라 (Do One Thing)**
- 함수는 오직 한 가지 일만 해야 한다.
- 그 “한 가지”는 명확하게 정의될 수 있어야 한다.
- 만약 추상화 수준이 섞여 있다면 이미 여러 가지 일을 하는 것.
1. **세 가지 이상 들여쓰기 금지**
- 함수 안에서 들여쓰기(중첩 if, for 등)는 2단계 이하로 제한.
- 중첩이 깊으면 리팩토링해서 함수로 분리해라.
1. **Switch 문은 객체지향으로 대체해라**
- switch 문은 보통 여러 일을 하게 되므로 피해야 한다.
- 다형성(Polymorphism)으로 대체하는 게 바람직함.
1. **함수 이름은 명확하게**
- 함수 이름은 무엇을 하는지 정확히 표현해야 함.
- 이름만 봐도 동작을 유추할 수 있어야 함.

```java
// 나쁜 예
processData()

// 좋은 예
generateMonthlyReport()
```

1. **함수 인수는 0~2개가 적절**
- 인수가 많아질수록 이해하기 어려워짐.
- 3개 이상이면 구조체나 DTO 객체로 묶는 걸 고려.
1. **출력보다 입력이 적어야 한다**
- 좋은 함수는 입력값만 받아서 출력해야 한다.
- 함수 안에서 외부 상태를 변경하면 부작용(side effect)이 생김 → 테스트 어려워짐.
1. **명령과 조회를 분리하라 (Command-Query Separation)**
- 무언가를 변경하는 함수는 값을 반환하지 말고,
값을 반환하는 함수는 상태를 변경하지 말라.
- 예시: saveUser()는 저장만 하고 값을 반환하지 않음
1. **오류 처리는 한 단계 추상화로 분리하라**
- try-catch는 함수 본문과 분리해라.
- 예외 처리를 별도 함수나 레벨에서 처리하는 게 좋음.

```java
try {
  readFile(file);
} catch (IOException e) {
  logError(e);
}
```

1. **중복을 제거하라**
- 중복된 로직은 별도의 함수로 추출하라.
- DRY 원칙(Don’t Repeat Yourself)

### 클린 코드가 말하는 좋은 함수는?

작고, 한 가지 일만 하며, 이름만 봐도 무슨 일을 하는지 알 수 있고 부작용이 없어야 한다!