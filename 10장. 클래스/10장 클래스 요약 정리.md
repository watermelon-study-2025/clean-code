> 깨끗한 클래스를 만들자!

# 클래스 체계
추상화 단계가 순차적으로 내려간다. (변수 목록 > 함수 목록)   

<br/>

## 변수 선언 순서
자바에서 멤버 변수의 초기화 순서
1. static 변수 선언부 : 클래스가 로드될 때 제일 먼저 초기화 됨 (메모리 Method 영역)
2. instance 변수 선언부 : 객체가 생성될 때 생성자 블록보다 앞서서 초기화 함 (메모리 Heap 영역)
3. 생성자 블록 : 객체가 생성될 때 JVM이 기본적으로 locking (메모리 Heap 영역)

자바 표준 컨벤션에서 변수 선언 순서도 초기화 순서와 비슷하다.     
static > instance 순서로 선언하며, 그 안에서는 접근 제한자 순서대로 선언한다 (public > protected > private 순)     

<br/>

## 함수 선언 순서
함수의 경우도 static > instance 메소드 순으로 선언하지만, 메서드는 접근 제한자 순이 아닌 기능별로 동일한 기능을 하는 메소드끼리 모아서 논리적으로 배치해야 한다.    
비즈니스 로직을 갖는 instance 메소드를 선언한 후에 standard 메소드를 배치한다.    
getter/setter는 가장 최하단에 작성한다.    

>standard 메소드
>java Object 에서 제공하는 메소드, toString(), equals(), hashCode() 등이 있다. 

<br/>

## 클래스 선언 순서
1. static 변수 : public > protected > private
2. instance 변수 : public > protected > private
3. 생성자
4. static 메소드 
5. instance 메소드 : 기능별로 묶어 논리적으로 배치
6. standard 메소드
7. getter/setter 메소드 

[Java Oracle code convention - Class and Interface Declarations](https://www.oracle.com/java/technologies/javase/codeconventions-fileorganization.html#1852)

<br/><br/>

# 캡슐화
변수와 유틸리티 함수는 가능한 공개하지 않는 게 좋다.     
protected는 캡슐화를 깨버리는 것에 주의하자. 하지만 때로는 테스트를 위해 변수나 유틸리티를 protected로 선언해 테스트 코드에 접근을 허용하기도 한다.   
캡슐화를 깨는 것은 언제나 최후의 수단으로 생각해야 한다.    

<br/><br/>    

# 클래스는 작아야 한다!
> 클래스를 설계할 때도, 함수와 마찬가지로, '작게'가 기본 규칙이다.   

함수의 크기를 물리적인 행 수로 측정했다면, 클래스는 클래스가 맡은 **책임**의 개수로 측정한다.   
메소드의 개수가 중요한게 아니다. 메소드 수가 적더라도 책임이 많은 경우가 있다.   

<br/>

## 클래스 이름     
클래스 이름은 해당 클래스의 책임을 기술해야 한다.     
- 이름이 모호하다는 건 클래스 책임이 너무 많다는 의미 (Processor, Manager, Super 등)    
- 클래스 설명은 if/and/or/but을 사용하지 않고서 25단어 내외로 설명이 가능해야 한다.    

<br/>

## 단일 책임 원칙 (SRP)
> 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다.     

**책임 = 변경할 이유**      
책임, 즉 변경할 이유를 파악하면 코드를 추상화하기도 쉬워진다.    

```java
// SRP를 위반하는 SuperOrderManager 클래스
public class SuperOrderManager {
    private List<Order> orders = new ArrayList<>();
    
    // 1. 주문 비즈니스 로직
    public void createOrder(String customerId, List<String> productIds) {
        Order order = new Order(customerId, productIds);
        orders.add(order);
    }
    
    // 2. 데이터베이스 저장
    public void saveToDatabase(Order order) {
        // DB 저장 로직
        Connection conn = DriverManager.getConnection("jdbc:mysql://...");
        // PreparedStatement 실행...
    }
    
    // 3. 이메일 발송
    public void sendConfirmationEmail(Order order) {
        // 이메일 발송 로직
        String emailBody = "주문이 완료되었습니다: " + order.getId();
        EmailService.send(order.getCustomerEmail(), emailBody);
    }
    
    // 4. 리포트 생성
    public void generateSalesReport() {
        // 리포트 생성 및 파일 저장
        StringBuilder report = new StringBuilder();
        report.append("총 주문: " + orders.size());
        FileWriter.write("report.txt", report.toString());
    }
    
    // 5. 프린터 출력
    public void printReceipt(Order order) {
        // 프린터로 영수증 출력
        String receipt = formatReceipt(order);
        PrinterService.print(receipt);
    }
}

// 이 클래스가 변경되는 이유들:
// 1. 주문 비즈니스 규칙 변경
// 2. 데이터베이스 스키마 변경  
// 3. 이메일 템플릿 변경
// 4. 리포트 형식 변경
// 5. 프린터 설정 변경
```

```java
OrderService        // 주문 => 주문 + DB 저장도 가능
DBService          // 데이터베이스 저장
EmailService       // 이메일 발송
ReportService      // 리포트 생성
PrintService       // 프린터 출력
```

주문 서비스와 DB 저장 서비스를 따로 두어도 되지만 **_"변경 이유가 같다면 함께 둬도 된다."_**

<br/>

### 단일 책임 클래스가 많아지면 더 복잡해지지 않을까?
대부분의 사람들은 '깨끗하고 체계적인 소프트웨어' 보다 '돌아가는 소프트웨어'에 초점을 맞춘다. 그것도 맞다.     
문제는 대다수가 프로그램이 돌아가면 일이 끝났다고 여기고 '깨끗하고 체계적인 소프트웨어'를 고민하지 않는다는 점이다.    

많은 개발자는 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 걱정한다.   
하지만 어느 시스템이든 익혀야 양은 클래스가 많든 적든 비슷한 경향이 있다.    

> _"도구 상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍 몇 개를 두고 모두를 던져 넣고 싶은가?_

큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.    
그래야 변경이 필요할 때 직접 영향을 받는 컴포넌트들만 이해해도 충분하기 때문이다.    

<br/>

## 응집도 
> 클래스는 응집도가 높아야 한다.    

응집도가 높다 = 클래스에 속한 메소드와 변수가 서로 의존하며 논리적 단위로 묶임     

- 클래스는 인스턴스 변수 수가 작아야 한다.
- 클래스 메소드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.

**_"함수를 작게, 매개변수 목록을 짧게"_**

<br/>

### 응집도를 유지하면 작은 클래스 여럿이 나온다. 
> 때로는 몇몇 메소드만이 사용하는 인스턴스 변수가 많아진다. 이런 경우는 새로운 클래스로 쪼개야 한다는 신호다.

큰 함수의 일부를 작은 함수로 쪼갤 때 함수에서 사용되는 변수를 모두 매개변수로 받아와야 하는가?    
=> 변수들을 인스턴스 변수로 승격시키면 그럴 필요가 없다. 하지만 이렇게 되면 클래스는 응집력을 잃는다.    

_클래스가 응집력을 잃는다면 쪼개라!_

응집력을 위해 클래스를 쪼개면 프로그램이 길어진다.   
1. 리팩토링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용하기 때문
2. 리팩토링 한 프로그램은 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용하기 때문
3. 가독성을 높이고자 공백을 추가하고 형식을 맞추었기 때문

클래스를 쪼개는 건 재구현을 말하는 게 아니다. 실제 동작 원리는 동일하게 가져간다.    
먼저 원래 프로그램의 정확한 동작을 검증하는 테스트 슈트를 작성하고 여러번에 걸쳐 조금씩 코드를 변경한다.    

<br/><br/>

# 변경하기 쉬운 클래스
> 깨끗한 시스템은 클래스를 체계적으롤 정리해 변경에 수반하는 위험을 낮춘다. 

```java
public class Sql {
	public Sql(String table, Column[] columns)
	public String create()
	public String insert(Object[] fields)
	public String selectAll()
	public String findByKey(String keyColumn, String keyValue)
	public String select(Column column, String pattern)
	public String select(Criteria criteria)
	public String preparedInsert()
	private String columnList(Column[] columns)
	private String valuesList(Object[] fields, final Column[] columns)
	// SRP 위반
	private String selectWithCriteria(String criteria)
	private String placeholderList(Column[] columns)
}
```

위 클래스는 책임이 두가지가 된다.    
1. 새로운 SQL문(DB 변경 등으로)을 지원하려면 이 클래스를 손대야 한다
2. 기존 SQL문 하나를 수정할 때도 반드시 SQL 클래스를 손대야 한다.

단일 책임 원칙을 위반한 클래스는 변경하기 어렵다.     
또한 클래스 일부에서만 사용되는 비공개 메소드는 코드를 변경할 여지를 주므로 파생 클래스를 만들어 필요한 곳에 넣는 방법이 좋다.    

```java
abstract public class Sql {
	public Sql(String table, Column[] columns)
	abstract public String generate();
}

public class CreateSql extends Sql {
	public CreateSql(String table, Column[] columns)
	@Override public String generate()
}

public class SelectSql extends Sql {
	public SelectSql(String table, Column[] columns)
	@Override public String generate()
}

public class InsertSql extends Sql {
	public InsertSql(String table, Column[] columns, Object[] fields)
	@Override public String generate()
	private String valuesList(Object[] fields, final Column[] columns)
}

public class SelectWithCriteriaSql extends Sql {
	public SelectWithCriteriaSql(String table, Column[] columns, Criteria criteria)
	@Override public String generate()
}

// .......

public class Where {
	public Where(String criteria)
	public String generate()
}

public class ColumnList {
	public ColumnList(Column[] columns)
	public String generate()
}
```

update 문을 추가할 때 기존 클래스를 변경할 필요가 전혀 없다. 단순히 SQL 클래스에서 파생한 새 클래스를 만들면 된다.    
위 클래스는 SRP를 만족하면서 동시에 OCP도 만족한다.   

<br/>

## 개방 폐쇄 원칙 (OCP)   
> 클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다.    

위 예제를 보면 파생 클래스를 생성하는 방식으로 새 기능 추가에 개방적인 동시에 다른 클래스들은 닫아놓은 방식으로 수정에 폐쇄적이다.   
새 기능을 수정하거나 기존 기능을 변경할 때는 건드릴 코드가 최소인 시스템이 바람직하다.    
새 기능을 추가할 때는 시스템을 확장할 뿐 기존 코드를 변경하진 않는다.   

<br/>

### 변경으로부터 격리   
- 구체적인 클래스(concrete) : 상세한 구현을 포함   
- 추상 클래스(abstract) : 개념만 포함   

상세한 구현에 의존하는 클래스는 테스트가 어렵다.   

**_결합도를 낮춰라!_**    
시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.    
**결합도가 낮다 = 각 시스템 요소가 다른 요소로부터, 변경으로부터 잘 격리되어 있다는 의미**    

<br/>

## 의존 역전 원칙 (DIP)
> 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙   

결합도를 줄이면 DIP를 따르는 클래스가 나온다.   
**추상화에 의존 = 간단히 말해 구현 객체가 아니라 인터페이스에 의존해야 한다는 의미**    
   
