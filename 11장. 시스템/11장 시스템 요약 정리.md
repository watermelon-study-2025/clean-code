> 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법

깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.     
그렇다면 높은 추상화 수준, 시스템 수준에서도 깨끗함을 유지하는 방법은?    

<br/><br/>

# "시스템 제작"과 "시스템 사용" 분리
> 제작은 사용과 다르다는 사실을 명심하자.    

소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다.     
- 시스템 제작 = 준비 과정(Startup Process) : 애플리케이션 객체를 제작하고 의존성을 서로 연결     
- 시스템 사용 = 런타임 로직    
   
대부분의 애플리케이션은 준비 과정 코드를 런타임 로직과 마구 뒤섞는다.    

<br/>

## 초기화 지연     
초기화 작업을 극한으로 미루다가 사용자가 필요로 할 때 진행하는 것   
객체나 데이터를 실제로 접근되거나 사용될 때까지 초기화를 미루는 것을 의미한다.    

```java
public Service getService() {
	if(service == null) 
		service = new MyServiceImpl(...);
	return service;
}
```

| 장점                                                                                                         | 단점                                                                                                                               |
| ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| - 성능 최적화 <br>: 불필요한 리소스 생성을 방지해 시스템의 전반적인 성능을 향상시킨다.<br>- 리소스 절약 : 메모리 낭비를 줄일 수 있다.<br>- null 에러를 막을 수 있다. | - getService 메소드가  MyServiceImpl 생성자 인수에 명시적으로 의존한다.<br>- 복잡성을 증가시킬 수 있다.<br>- 스레드 안정성 : 동기화 문제가 발생할 수 있다. <br>- 단일 책임 원칙을 위반한다. |
    
테스트 시   
1. 메소드 호출 전에 적절한 테스트 전용 객체(Test Double, Mock Object 등)를 service 필드에 할당해야 한다.   
2. 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로도 테스트 해야한다. (null인 경로와 null이 아닌 경로)   

위의 코드가 가진 두가지 책임   
1. 해당 객체가 원래 가지고 있는 비즈니스 로직   
2. 리소스를 생성 및 초기화 하는 책임   

초기화 지연을 한번 정도 사용한다면 별로 심각한 문제가 아니다. 하지만 많이 사용하게 되면 모듈성은 저조해지며 중복이 심각해진다.   
   
체계적이고 탄탄한 시스템을 만들고 싶다면 모듈성을 깨서는 안된다.   
객체를 생성하거나 의존성을 연결할 때도 마찬가지다.   
설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.   

<br/>

## Main 분리
> 애플리케이션의 시작점(main)과 실제 비즈니스 로직을 분리하는 것

생성과 관련한 aspect는 모두 Main이나 main이 호출하는 모듈로 옮기고    
나머지 시스템은 "모든 객체가 생성되었고, 모든 의존성이 연결되었다"고 가정한다.   

모든 의존성은 main에서 애플리케이션 쪽을 향한다.    
애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.    
모든 객체가 적절하게 생성되었다고 가능하고 애플리케이션 로직이 동작한다.   

<img src="https://github.com/user-attachments/assets/ddbb39f0-0a20-4fdc-b25c-9576831e17ff" height="300">

<br/>

## Factory
> 관련된 객체들을 한꺼번에 만들 수 있게 도와주는 공장    

때로는 객체가 생성되는 시점을 애플리케이션이 결정할 때도 있다.    
이럴 때는 추상 팩토리 패턴(Abstract Factory Pattern)을 사용한다.   

ex) LineItem을 생성하는 시점은 애플리케이션이 결정하지만, LineItem을 생성하는 코드는 애플리케이션이 모른다.    

<img src="https://github.com/user-attachments/assets/8079c0ee-6a38-4ab3-8734-00ae2c3cb896" height="300">

<br/>

## 의존성 주입   
> 제어 역전 기법을 의존성 관리에 적용한 매커니즘   

제어 역전 기법 : 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.    
새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.    

### 제어의 역전
의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다. 
대신에 이런 책임을 다른 '전담' 매커니즘에게 넘긴다. 

대개 책임질 매커니즘으로 'main' 루틴이나 특수 컨테이너를 사용한다. (ex. Spring Container)

### DI 컨테이너 
클래스는 의존성을 해결하려고 하지 않고 완전히 수동적이다. 
DI 컨테이너가 대신 객체의 인스턴스를 만든 후 의존성을 설정해준다. 
실제로 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시한다. 

대다수의 DI 컨테이너는 필요하기 전까지는 객체를 생성하지 않고, 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다.

<br/><br/>

# 확장   
> "처음부터 올바르게" 시스템을 만들 수 있다는 믿음은 미신이다.

<br/>

## 코드 수준
- 애자일 방식
- 테스트 주도 개발
- 리팩토링 

<br/>

## 시스템 수준
>_"소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다."_   

소프트웨어는 수명이 짧기 때문에 아키텍처의 점진적인 발전이 가능하다.   
ex) EJB > POJO > Spring    

**관심사를 잘 분리하자!**
EJB의 경우 비즈니스 논리가 EJB 애플리케이션 컨테이너에 강하게 결합되어 버린다.   
EJB 코드를 프레임워크 밖에서 재사용하기란 사실상 불가능하다.   
이렇게 되면 객체 지향 프로그래밍이라는 개념 자체가 흔들려 버린다.  

<br/>

## 횡단 관심사(cross-cutting concern)   
영속성과 같은 **관심사**는 애플리케이션의 객체 경계를 넘나든다.   
따라서 모든 객체가 전반적으로 동일한 방식을 이용하도록 공통화 해야 한다.   
=> 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다.   

<br/>

## AOP (관점 지향 프로그래밍)    
관점(Aspect) : "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다."   

<br/><br/>

# 자바에서 사용하는 관점(Aspect)   

<br/>

## 자바 프록시
자바 프록시는 단순한 상황에 적합하다.    
JDK 동적 프록시의 경우 인터페이스만 지원하므로 클래스 동적 프록시를 사용하려면 CGLib, ASM, Javassist 등과 같은 바이트 코드 처리 라이브러리가 필요하다.    

### 프록시의 단점    
1. 코드 '양'과 크기가 많고 복잡해진다.    
2. 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다!    
3. AOP에 필요한 시스템 단위로 실행 '지점'을 명시하는 매커니즘도 존재하지 않는다!    

<br/>

## 순수 자바 AOP 프레임워크 
> Spring AOP, JBoss AOP

순수 자바 관점을 구현하는 여러 자바 프레임워크는 내부적으로 프록시를 사용한다. (= AspectJ를 사용하지 않는다)    

설정 파일이나 API를 사용해 애플리케이션 기반 구조를 구현한다.   
(영속성, 트랜잭션, 보안, 캐시, 장애조치와 같은 횡단 관심사도 포함)   
=> 즉, 스프링이나 JBoss 라이브러리의 관점을 명시한다.   

### POJO
스프링은 비즈니스 논리를 POJO로 구현한다. 
POJO는 순수하게 도메인에 초점을 맞춘다. 엔터프라이즈 프레임워크나 다른 도메인에 의존하지 않는다. 

### Spring
빈은 XML 설정 파일을 통해 직접 추가가 가능하다.   
또 애플리케이션에서 DI 컨테이너에게 시스템 최상위 객체를 요청하려면    

```java
// 스프링 관련 자바 코드가 거의 필요 없다. 
XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource("app.xml", getClass()));
Bank bank = (Bank) bf.getBean("bank");
```

스프링은 POJO 기반으로 구현해 애플리케이션이 사실상 스프링과 독립적이다.   
EJB 시스템이 지녔던 강한 결합 문제가 모두 사라지게 된다.   

<br/>

## AspectJ 관점
관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어   

### AspectJ
AOP를 실제로 구현할 수 있게 해주는 라이브러리

- 모든 자바 객체에 적용 가능
- 메소드, 생성자, 필드 접근 등 모든 곳에 적용 가능
- 컴파일 타임에 바이트 코드를 직접 조작하는 방식 (CTW, LTW 선택 가능)

```java
@Aspect
public class SecurityAspect {
    
    // 포인트컷 정의
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // Before 어드바이스
    @Before("serviceLayer()")
    public void checkSecurity(JoinPoint joinPoint) {
        System.out.println("보안 체크: " + joinPoint.getSignature().getName());
    }
    
    // Around 어드바이스 (메서드 실행 전후 제어)
    @Around("serviceLayer()")
    public Object measureTime(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        
        Object result = pjp.proceed(); // 실제 메서드 실행
        
        long end = System.currentTimeMillis();
        System.out.println("실행 시간: " + (end - start) + "ms");
        
        return result;
    }
    
    // 예외 발생 시
    @AfterThrowing(pointcut = "serviceLayer()", throwing = "ex")
    public void handleException(Exception ex) {
        System.out.println("예외 발생: " + ex.getMessage());
    }
}
```

<br/><br/>

# 테스트 주도 시스템 아키텍처 구축 (TDD)
AOP를 통해 관심사를 분리하고 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면,    
코드 수준에서 아키텍처 관심사를 분리할 수 있다면 진정하면 TDD가 가능해진다.   

BDUF : 구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법    
BDUF 방식 대신 '아주 단순하면서도' 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 빨리 출시한 후 확장해나가도 좋다.    

<br/>

## MVP (Minimum Viable Product)   
> 최소 기능 제품   

제품이나 서비스의 가장 기본적이면서 핵심적인 기능만을 포함한 초기 버전    
최소한의 기능만 가진 제품을 출시 해 시장 반응을 빠르게 검증하고 피드백을 바탕으로 제품을 개선해 나가는 방식    

>_"최선의 시스템 구조는 각기 POJO(또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 
>이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 과점이나 유사한 도구를 사용해 통합한다. 
>이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다."

<br/><br/>

# 의사 결정을 최적화하라   
가장 적합한 사람에게 책임을 맡기는게 가장 좋다.    

최대한의 정보를 모아 최선의 결정을 내리기 쉽다.    
관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공하며 그 덕에 최적의 결정을 내리기가 쉬워진다.    

<br/><br/>

# 명백한 가치가 있을 때 표준을 현명하게 사용하라
표준을 사용하면 아이디어나 컴포넌트를 재사용하기 쉽고, 캡슐화 하기도 쉽고, 사람 구하기도 쉽지만   
때로는 표준을 만드는 시간이 너무 오래 걸리거나    
여러 형태로 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려나는 경우도 있다.    

<br/><br/>

# 시스템은 도메인 특화 언어가 필요하다   
> 죽지도 않고 또 나온 DSL

DSL :  간단한 스크립트 언어나 표준 언어로 구현한 API    

>_"도메인 특화 언어를 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 도메인을 POJO로 표현할 수 있다."_   

<br/><br/>

# 깨끗한 시스템이란?   
- 도메인 논리가 명확한 시스템
- 기민성이 높아 TDD 적용이 편한 시스템
- 모든 추상화 단계에서 의도가 명확히 표현되는 시스템
- POJO를 작성하고 관점(또는 과점과 유사한) 매커니즘을 사용해 각 구현 관심사를 분리한 시스템

