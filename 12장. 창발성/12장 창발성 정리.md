## 12장 창발성 (創發性, Emergence)

### 사전적 의미

- 남이 모르거나 하지 아니한 것을 처음으로 또는 새롭게 밝혀내거나 이루어 내는 성질.

### 기본 개념

- 작은 구성 요소들이 모여서, 개별 요소에는 없는 새로운 특성이나 패턴이 나타나는 현상
- IT, 인공지능 예시 :  대규모 언어 모델(LLM)도 개별 뉴런 수준에서는 단순한 연산을 할 뿐인데, 수십억 개의 파라미터가 연결되면 문맥 이해, 창의적인 글쓰기, 추론 같은 능력이 나온다.
- 사회 현상 예시 : 개인은 단순한 소비 행동을 하지만, 시장 전체로 보면 경제 호황/불황, 트렌드 형성 같은 거시적인 패턴이 발생한다.

### 클린 코드에서의 창발성

- 좋은 설계가 만들어 만들어내는 코드 품질 관점
- 단순한 규칙과 습관을 잘 지키다 보면, 코드 전체 구조가 **자연스럽게 깔끔해지고 유지보수가 쉬운 형태로 “창발” 한다는 개념**으로 사용

→ “좋은 코드”는 한 번에 거창하게 설계해서 만드는 게 아니라 **작은 규칙들을 잘 지키다 보니 결과적으로 Emergent Design이 되는것!**

### 소프트웨어 설계 품질을 높여주는 켄트 벡이 제시한 단순한 설계규칙 4가지

| 규칙                 | 설명                                                                                                                    |
|----------------------|-------------------------------------------------------------------------------------------------------------------------|
| 모든 테스트를 통과한다    | - 기능이 의도대로 동작해야 하고, 자동화된 테스트로 항상 확인 가능해야 함<br>- 테스트 케이스 작성 시 설계 품질 향상 → 작고 목적이 명확한 클래스 생성 → 테스트가 쉬워짐<br>- 리팩토링 전 충분한 테스트 코드 작성으로 안전한 리팩토링 가능→ 리팩토링 후에도 기존 기능 정상 작동 여부 반드시 확인<br>- 지속적인 테스트로 코드 품질과 안정성 유지 |
| 중복을 없앤다            | - 같은 로직이 여러 곳에 있으면 수정 시 버그 발생 가능성 증가<br>- 공통화, 함수 추출, 상수화 등을 통해 중복 제거                                      |
| 프로그래머의 의도를 표현한다 | - 변수명, 함수명, 클래스명이 코드 목적을 명확히 드러내야 함<br>- 주석보다 코드 자체가 의도를 전달하도록 작성                                           |
| 클래스와 메서드 수를 최소화한다 | - 지나치게 쪼개거나 추상화 시 오히려 복잡도 증가<br>- 불필요한 클래스와 메서드 없이 최소한으로 설계                                                |


### 예시 코드

1. 중복제거
    - 중복 제거 전
    
    ```python
    # 사각형
    def calc_area_rect(width, height):
        return width * height
    
    # 정사각형
    def calc_area_square(side):
        return side * side
    
    # 평행사변형
    def calc_area_parallelogram(base, height): 
        return base * height
       
    # 사각형 넓이 구하는 메서드
    # calc_area_rect와 calc_area_parallelogram이 중복된 구조
    ```
    
    - 중복 제거 후
    
    ```python
    public class AreaCalculator {
    
        public int calcAreaRect(int base, int height) {
            return base * height;
        }
    
        public int calcAreaSquare(int side) {
            return calcAreaRect(side, side);
        }
    }
    
    # calcAreaRect와 calcAreaParallelogram은 중복이라 하나로 통합 가능
    # 정사각형은 직사각형의 특수 케이스라서 재사용
    ```
    

1. 의도 표현 예시
    
    ```java
    // 나쁜 예
    public int func(int x, int y) {
        return x * y;
    }
    
    // 좋은 예 : 메서드명과 매개변수명이 함수 의도록 명확하게 나타낸다.
    public int calculateArea(int width, int height) {
        return width * height;
    }
    ```
    

1. 테스트 통과 확인(Jest 예시)
    
    ```jsx
    test('calculateArea returns correct area', () => {
      expect(calculateArea(5, 10)).toBe(50);
      expect(calculateArea(3, 3)).toBe(9);
    });
    
    /*
    1. test 함수 : Jest에서 테스트 케이스를 정의할 때 쓰는 함수
    	•	첫번째 인자는 테스트 이름 또는 설명 문자열 
    	  (여기서는 'calculateArea returns correct area')
    	•	두번째 인자는 실제 테스트할 내용을 담은 함수(화살표 함수 () => { ... })
    2. expect 함수 : expect() 안에는 테스트할 실제 값을 넣는다
    	•	여기서는 calculateArea(5, 10) 결과값을 검사
    3. toBe() 메서드
    	•	expect로 받아온 값이 뒤에 있는 값과 일치하는지 확인하는 메서드
    	•	calculateArea(5, 10)이 50과 같아야 테스트가 성공
    4. 전체 동작 흐름
    	•	테스트 러너가 test 함수를 실행하면,
    	•	calculateArea(5, 10)을 호출해서 50이 나오는지 체크 → 맞으면 성공
    	•	calculateArea(3, 3)을 호출해서 9가 나오는지 체크 → 맞으면 성공
    	•	둘 다 맞으면 이 테스트 케이스는 ‘통과’
    */						
    ```
    
    - 성공 시 예시
        
        ```
         PASS  ./areaCalculator.test.js
          ✓ calculateArea returns correct area (5 ms)
        
        Test Suites: 1 passed, 1 total
        Tests:       1 passed, 1 total
        Snapshots:   0 total
        Time:        1.234 s
        
        * 터미널(명령 프롬프트)에서 jest 명령어를 치거나 test 스크립트를 실행하면 
        결과가 콘솔에 출력된다. *
        ```
        
    - 실패 시 예시
        
        ```
         FAIL  ./areaCalculator.test.js
          ✕ calculateArea returns correct area (10 ms)
        
          ● calculateArea returns correct area
        
            expect(received).toBe(expected) // Object.is equality
        
            Expected: 50
            Received: 40
        
              2 | test('calculateArea returns correct area', () => {
              3 |   expect(calculateArea(5, 10)).toBe(50);
              4 |   expect(calculateArea(3, 3)).toBe(9);
              5 | });
              
         * 어느 테스트케이스가 실패했는지, 기대값과 실제값이 뭔지 상세히 알려준다. *     
        ```

## 생각해보자

### 1. 실무에서 창발성 적용할 수 있나?

- 4가지 규칙을 기억하고 실제로 활용 하여 작업하도록 한다.
- 코드 작성 후, 일정 기간마다 리팩토링 시간을 따로 가지고 품질 개선을 한다.
    - 테스트를 기반으로 안전하게 코드를 다듬어 나간다.

### 2. 설계는 처음부터 완벽할 필요가 없고, 작은 개선들이 모여서 좋은 설계를 창발시킨다.

 하지만 업무 하면서 자주 하는 생각이 제대로 설계가 되야 제대로 만든는게 아닌가? 도대체 어떻게 요구사항을 정리해서 기획, 설계 했길래 이따위로 만든건가? 인데 내가 잘못 생각 하고 있는 것인가?

- 우리가 보는 대부분의 레거시 코드나 문제가 있는 코드는 설계가 처음부터 엉망진창이었을 가능성이 크다.
→ 이런 코드는 클린 코드에서 말하는 창발성과는 거리가 멀다. 저자는 창발성 설계를 주장하면서도 **더러운 코드를 방치하라고 말한적이 없다!**
- 클린 코드에서 말하는 '창발적 설계'의 진짜 의미
    - 클린 코드에서 말하는 창발적 설계는 '설계를 하지 말자'는 게 아니다. 핵심은!!
    - 시작은 작게, 하지만 깨끗하게: 처음부터 완벽한 미래를 예측해서 거대한 설계를 짜지 않아도 된다. 그 대신, 현재 필요한 기능에 맞춰 '깨끗하고 단순한' 설계를 먼저 만들어야 한다.
    - 점진적인 개선: 그 깨끗한 설계를 기반으로 기능이 추가되거나 요구사항이 바뀌면, 그때그때 코드를 개선(리팩토링)하면서 더 나은 설계를 만들어 간다.
    - 작은 개선이 모여서 큰 설계가 된다.

### 2-1. ‘작게 시작’ 할 때 확장성은 고려해야되는가 무시해도 되는가?

- 무시하면 안된다!!!!! 다만, 미래를 예측해서 복잡한 구조를 미리 만들어두는것은 피해야 한다.
- ‘작게 시작’과 ‘확장성’은 서로 충돌하는 것이 아니라 어떻게 확장성을 고려할 것인가에 대한 접근 방식이 다른 것!

→ 클린 코드에서 말하는 방식은 변경에 유연하게 대응하도록 만들어라

- 지금 당장 필요한 기능에 집중해서 깨끗하고 단순하게 코드를 작성한다.
- 대신, 변경이 생겼을 때 쉽게 고치거나 확장할 수 있도록 코드를 유연하게 작성한다.
- 예 :
    
    > 인터페이스 활용
    지금은 ‘메일발송기능’만 필요한데 미래에 ‘문자발송기능‘이 필요할 수 있다고 해서 예측해서 복잡한 코드를 미리 만드는 대신, 일단 발송기능 인터페이스를 정의해 두고 거기에 맞춰서 메일발송기능을 구현한다. 나중에 문자가 필요해지면 인터페이스에 맞춰 새로운 클래스만 추가하면 된다.
    > 

### 3. 이런 상황에서도 클린 코드의 원칙을 적용할 방법이 있다.

> ***보이스카웃 규칙*
캠핑장을 떠날 때는 처음 왔을 때보다 더 깨끗하게 만들어 놓고 떠나라**
> 
- **버그를 수정하거나 기능을 추가 할 때, 그 부분의 코드를 내가 처음 봤을 때보다 조금 더 깨끗하게 만들자.**
- 한번에 좋아지기는 어렵겠지만 조금씩 개선해 나가면 이런 작은 노력이 모여서 ‘창발적인 개선’을 만들어 낼 수 있다.
