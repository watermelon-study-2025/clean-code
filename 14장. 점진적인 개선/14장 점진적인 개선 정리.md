# 14장. 점진적인 개선

> 확장성이 부족한 모듈을 개선하는 과정을 보며 학습


**명령행 인수 구문이란?**

**CLI(Command Line Interface)** 기반 프로그램에서 **프로그램 실행 시 전달하는 인수(argument)**를 해석하는 형식과 규칙

```bash
# 실행 예시
java -jar myapp.jar --env=prod --port 8080 --debug
```

## 명령행 인수를 분석하는 유틸리티 "Agrs"

> CLI에서 전달한 인수를 파싱하여, 각 Type으로 변환해주는 Parser 클래스 예제
> 

### 사용 예제

**CLI**

```java
java Main -l -p 8080 -d /home/logs
```

**Agrs**

- args 예시

```java
String[] args = {"-l", "-p", "8080", "-d", "/home/logs"};
```

- 사용 예시

```java
public static void main(String[] args) {
	try {
		// 일종의 Parser 클래스 Agrs로 인수 파싱
		Agrs agr = new Agrs("l,p#,d*", args);
		
		// 인수 l,p,d를 boolean, int, String으로 변환
		boolean logging = arg.getBoolean('l');
		int port = agrs.getInt('p');
		String directory = arg.getString('d');
		
		// ...
	} catch (AgrsException e) {
		// 인수 파싱 실패 ...
	}
}
```

<br/>

## 점진적인 개선 과정

### **1. 코드 개선을 위해 TDD(테스트 주도 개발) 기법 채택**

- 코드가 이전과 똑같이 작동하는 지 확인할 수 있어야, 점진적인 개선 가능
- 단위 테스트를 미리 구현해 놓을 것
- 단위 테스트를 통해, 변경 후에도 이전과 동일한  결과인지 확인하며 개선

### 2. 점진적인 리팩토링 과정

> ✅ git에 따로 작성해놓은 예제를 보며 스터디


1. **초기 코드**
    1. Boolean 타입만 지원
    2. String 타입 추가 **⇒ 개선의 필요성을 느낌**
        
        > 새 인수 타입을 추가하려면, 주요지점 3곳에 코드를 추가해야 함
        > 
        - **parse :** 스키마 구문 분석하는 부분 `parseSchemaElement(String element)`
        - **set :** 명령행 인수 유형을 분석하여, 진짜 Type으로 변환하는 부분 `setArgument(char argChar)`
        - **get :** Type별 get 메서드를 구현한 부분 `getBoolean(char)` , `getString(char)`
2. **공통되는 영역을 클래스화하고, 객체에 역할 위임**
    1. `ArgumentMarshaler` 클래스 추가
    2. boolean 타입 getter, setter 클래스에 위임
    3. String 타입 getter, setter 클래스에 위임
    4. int 타입 추가 및, getter, setter 클래스에 위임
    5. Type별 **파생클래스**에 getter, setter 위임
    6. Type별로 반복 선언되는 Map을, **단일 Map으로 통합**
    7. **setArgument**의 Type별 분기 처리를 클래스에 위임
        - args배열을 list로 변환
        - set 함수의 매개변수를 1개로 줄이기 위해, iterator를 매개변수로 전달
        - type 별 set~Arg 처리를 통합하고, 클래스에 완전히 위임
        
        **⇒ 1차 개선 완료: 이제 새로운 인수 타입을 추가하기 쉬운 구조가 됨**
        
    8. double 타입 추가 및 테스트
        
        ```java
        public void testSimpleDoublePresent() throws Exception {
            Args args = new Args("x##", new String[] { "-x", "42.3" });
            assertTrue(args.isValid());
            assertEquals(1, args.cardinality());
            assertTrue(args.has('x'));
            assertEquals(42.3, args.getDouble('x'), .001);
        }
        ```
        
        ```java
        public void testInvalidDouble() throws Exception {
            Args args = new Args("x##", new String[] {"-x", "Forty two"});
            assertFalse(args.isValid());
            assertEquals(0, args.cardinality());
            assertFalse(args.has('x'));
            assertEquals(0, args.getInt('x'));
            assertEquals("Argument -x expects a double but was 'Forty two'.",
                         args.errorMessage());
        }
        ```
        
        ```java
        public void testMissingDouble() throws Exception {
            Args args = new Args("x##", new String[] {"-x"});
            assertFalse(args.isValid());
            assertEquals(0, args.cardinality());
            assertFalse(args.has("x"));
            assertEquals(0.0, args.getDouble("x"), 0.01);
            assertEquals("Could not find double parameter for -x.",
                         args.errorMessage());
        }
        ```
        

1. **추가 개선:  예외 처리 코드 별도의 클래스로 분리**
    - 특히 errorMessage()는 Args와 관련이 없어, SRP원칙을 위반하므로 별도 클래스의 메서드로 분리
