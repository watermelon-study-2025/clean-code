# 클린코드 17장 – 냄새와 휴리스틱

> **좋은 프로그래머의 태도와 습관**

“클린코드는 규칙을 암기하는 게 아니라 태도의 문제다.”

“좋은 코드는 결국 **좋은 동료**를 위한 배려다.”

“우리가 남기는 코드는 미래의 나, 혹은 동료가 읽는다.”
> 

## **1. 코드 냄새(Code Smell)**

### **정의**

- 코드 냄새는 코드가 **문법적으로 틀리진 않지만**, 설계·유지보수·확장 측면에서 문제를 일으킬 가능성이 있는 신호
- 즉, 동작은 하지만 “뭔가 이상하다”라고 느껴지는 코드 특징

<aside>
💡

## **코드 냄새 용어의 기원**

- **원래 개념 제안자**:
    
    → **Kent Beck (켄트 벡)**
    
    - *Martin Fowler의 『Refactoring: Improving the Design of Existing Code』 (1999)* 책에서 코드 냄새를 정리하면서, Fowler가 분명히 “이 용어는 Kent Beck이 만들어낸 것”이라고 밝힘.
    - 즉, **Kent Beck이 처음 말했고, Martin Fowler가 널리 퍼뜨렸다**는 게 정설이다.
- **마틴 파울러의 역할**:
    - 코드 냄새를 단순한 아이디어 차원에서 끝내지 않고, 구체적인 분류 체계(중복 코드, 긴 메서드, 거대 클래스 등)를 만들고 책에 체계적으로 정리함.
    - 그래서 대부분 사람들이 Fowler 이름과 함께 기억하는 것.

---

## **정리**

- **최초 사용**: Kent Beck (경험적으로 “코드가 냄새 난다”는 표현을 함)
- **대중화·정리**: Martin Fowler (Refactoring 책에서 본격적으로 소개)

---

💡 쉽게 말하면:

- “코드 냄새”라는 말을 처음 툭 던진 건 **켄트 벡**
- 그걸 카테고리별로 정리해서 세계적으로 유명하게 만든 건 **마틴 파울러**
- **마틴**은 “코드 냄새”를 나쁜 설계의 징후로 다루고, 휴리스틱은 좋은 설계로 가기 위한 지침으로 “냄새를 고치는 원칙”을 강조
</aside>

### **특징**

| 특징 | 설명 |
| --- | --- |
| 재사용성 낮음 | 같은 코드가 반복되고 있음 → 수정 시 여러 곳 수정 필요 |
| 가독성 낮음 | 읽기 어렵고 의도를 파악하기 어려움 |
| 유지보수 어려움 | 기능 추가, 버그 수정 시 예상치 못한 사이드 이펙트 발생 가능 |
| 구조적 문제 | 클래서, 메서드, 모듈의 책임이 불분명하거나 과도하게 복잡 |

### **대표적인 코드 냄새 예시**

1. **중복 코드(Duplicate Code)**: 같은 코드가 여러 곳에 있음
2. **긴 메서드(Long Method)**: 한 메서드가 너무 많은 일을 함
3. **큰 클래스(Large Class / God Class)**: 클래스가 너무 많은 책임을 가짐
4. **긴 매개변수 목록(Long Parameter List)**: 함수 호출 시 매개변수가 많음
5. **주석 과다(Comments)**: 코드로 설명 가능함에도 주석에 의존
6. **스위치문 과다(Switch / Case)**: 다형성으로 해결 가능한데 조건문으로 처리

💡 요약: “코드가 뭔가 찝찝하다, 수정할 때 위험하다” → 코드 냄새

### 더 찾아본 내용

1. 환경 E2 : 여러 단계로 테스트 한다. 모든 단위 테스트는 한 명령으로 돌려야 한다.
    - 소프트웨어 개발할 때 테스트는 보통 여러 단계로 나뉜다.
        - **단위 테스트(Unit Test)** – 함수, 클래스 같은 작은 단위 검증
        - **통합 테스트(Integration Test)** – 모듈 간 상호작용 확인
        - **시스템 테스트(System Test)** – 전체 시스템 동작 확인
        - **인수 테스트(Acceptance Test)** – 사용자가 원하는 요구사항 충족 여부
    - “한 명령으로 돌리라”의 뜻
        - 테스트가 여러 단계로 나뉘어 있더라도, **개발자가 테스트를 실행할 때는 단 하나의 명령(혹은 버튼)만 누르면 전체가 순차적으로 자동 실행되도록 하라**는 원칙
        
        → 즉, **“테스트 실행 절차를 자동화해서 사람이 여러 번 명령 내릴 필요가 없게 하라”**는 의미
        
    - 결론은 여러단계의 테스트가 있다고 해서 개발자가 매번 일일이 실행하지 말고모든것을 자동으로 묶어서 한방에 실해되게 만들면 개발자도 귀찮지 않고 테스트도 절대 빼먹지 않게 된다.
2. 일반 G14 : 기능 욕심
    - 소프트웨어 개발에서 **Feature Creep** 또는 **Feature Bloat**라고 불리는 개념이랑 맞닿아 있다.
        - Feature Creep (피처 크립): 계속해서 새로운 기능을 추가하다 보니, 제품이 처음 의도와 달라지고 복잡해지는 현상
        - Feature Bloat (피처 블로트): 너무 많은 기능 때문에 프로그램이 무겁고 사용하기 어려워지는 상태
    - 필요 이상으로 기능을 계속 추가하려는 경향을 말하며, 사용자의 핵심 요구사항보다 “이것도 있으면 좋지 않을까?” 하면서 기능이 늘어나고, 결국 **프로그램이 복잡하고 무겁게 변한다.**
    - 왜 문제냐면
    
    | 문제 | 설명 |
    | --- | --- |
    | 복잡성 증가 | 기능이 많아질수록 코드도 비대해지고 유지보수 어려워짐 |
    | 사용성 저하 | 사용자는 단순한것을 원하는데 메뉴/욥션이 너무 많이 오히려 불편해짐 |
    | 품질 저하 | 자원(시간, 인력)이 분산돼서 핵심 기능 안정성이 떨어짐 |
    | 일정 지연 | “이 기능만 추가하자”가 쌓여서 프로젝트 마감 지키지 못 함 |
    | 기술 부채 증가 | 급하게 붙인 기능들이 나중에 발목 잡음 |
    
    - 예시 :
    - 소프트웨어 :
        - 워드 프로세서에 잘 쓰이지 않는 수백 가지 서식 기능
        - **모바일 앱에 "QR코드, 채팅, 쇼핑몰, 게임"까지 다 붙여버리는 경우**
    - 개발자 개인 습관 :
        - 함수 만들면서 "나중에 쓸지도 몰라"하고 필요없는 옵션 파라미터를 잔뜩 넣음
        - 간단한 API만들면 되는데, 인증/버전관리/로깅 등 미리 다 얹으려고 함
    
    - 피하는 방법 :
        - **YAGNI (You Aren’t Gonna Need It)** 원칙
            - “필요하다고 확실히 검증되지 않은 기능은 구현하지 마라.”
        - **KISS (Keep It Simple, Stupid)**
            - 단순하게 유지하라
        - **MVP/Agile 방식**
            - 최소 기능만 먼저 출시 → 사용자 피드백 보고 진짜 필요한 기능만 추가
3. 일반 G18 : 부적절한 Static 함수
    
    
    | 구분 | 안전하게 쓰는 경우 | 쓰면 안 되는 경우 |
    | --- | --- | --- |
    | 접근 대상 | 인스턴스 상태와 무관 | 인스턴스 상태를 변경해야 하는 경우 |
    | 목적 | 순수 기능, 유틸리티, 팩토리, 상수 제공 | 객체 지향 원칙을 따르는 다형성, 상태 관리 필요 |
    | 장점 | 어디서든 동일한 기능 제공, 코드 간결, 재사용 용이 | — |
    | 문제점 | — | 다형성/상속 불가, 테스트 어려움, 상태 공유 시 혼란 발생 |
    | 예시 | `add(int a, int b)`, `isEmpty(String s)`, `createAdminUser()`, `PI` | 인스턴스 카운터 증가, static으로 DB 연결/설정 변경 등 |
    - **독립적이고 상태에 의존하지 않는 함수** → static OK
    - **객체 상태에 따라 동작하거나 다형성을 활용해야 하는 함수** → static NO

## **2. 휴리스틱(Heuristic)**

### **정의**

- 휴리스틱은 **문제를 완전히 정확하게 풀 수 없을 때, 경험적 규칙이나 직관을 기반으로 해결책을 찾는 방법**
- 완전한 정답은 아니지만, 코드 냄새를 발견하고 개선하는 지침 역할
- 클린코드에서는 ‘좋은 코드 작성 경험’과 ‘냄새 제거 방법’을 휴리스틱으로 제시

<aside>
💡

휴리스틱(Heuristic)”이라는 단어 자체는 **그리스어 ‘εὑρίσκω (heurískō)’**에서 왔다.

- 뜻은 **“발견하다, 찾아내다”**
- 즉, “직관과 경험을 통해 문제 해결 방법을 발견한다”라는 의미가 담겨 있음

컴퓨터 과학에서는 **완벽한 알고리즘보다는 경험적 규칙이나 근사해를 이용한 문제 해결 방법**을 가리킬 때 이 단어를 그대로 차용한 것.

쉽게 말하면, **“정답을 바로 주는 공식은 아니지만, 경험상 잘 먹히는 방법”**이라는 의미에서 쓴다고 볼 수 있다.

</aside>

### 특징

| 특징 | 설명 |
| --- | --- |
| 경험 기반 | 이전 경험이나 관찰에서 나온 규칙 |
| 완벽하지 않음 | 100% 정확하지는 않지만 대부분의 경우 효과적 |
| 빠른 판단 가능 | 복잡한 분석 없이 문제 가능성을 판단 가능 |

### **예시**

- **코드 냄새 발견 휴리스틱**:
    - “함수가 한 화면에 안 들어갈 정도로 길다면 긴 메서드일 가능성 높다”
    - “클래스에 20개 이상의 메서드가 있으면 God Class(만능 클래스)일 가능성이 높다” → 냄새날 확률이 높다.
- **Refactoring 지침 휴리스틱**:
    - 중복 코드 → 메서드로 추출
    - 긴 메서드 → 작은 메서드로 분리
    - 긴 매개변수 → 객체로 묶기

즉, 휴리스틱은 **‘경험 기반 눈대중 규칙’**처럼 생각 할 수 있다. 반드시 맞는 건 아니지만 대부분의 경우 문제 해결에 도움이 된다.

## 3. 코드 냄새와 휴리스틱의 관계

| 구분 | 코드 냄새(Code Smell) | 휴리스틱(Heuristic) | 관계 |
| --- | --- | --- | --- |
| 정의 | 코드 자체에서 드러나는 문제의 징후, 즉 “문제가 있을 수 있는 코드” | 문제 해결이나 설계 판단을 돕는 경험적 규칙, 즉 “좋은 설계 지침” | 휴리스틱은 코드 냄새를 식별하고 개선하는 가이드 역할을 함 |
| 목적 | 코드의 품질 저하, 유지보수 어려움 경고 | 설계와 구현에서 최선의 선택을 돕고 실수를 줄임 | 코드 냄새를 발견하면, 휴리스틱을 참고해 리팩토링 방향 결정 |
| 예시 | 긴 함수(Long Method), 중복 코드(Duplicate Code), 과도한 클래스(Coupler) | “함수는 한 가지 일만 하도록 하라”, “중복을 제거하라”, “의도를 명확히 드러내라” | 긴 함수를 발견하면 ‘한 가지 일만 하도록 분리’라는 휴리스틱 적용 |
| 활용 | 코드 리뷰, 리팩토링 우선순위 결정 | 개발 과정에서 설계 판단, 테스트 전략, 리팩토링 지침 | 코드 냄새를 발견 → 휴리스틱 적용 → 코드 개선 |

→ **코드 냄새는 문제 신호**, **휴리스틱은 문제 해결 규칙**이라고 보면 돼. 냄새만 보고 끝나는 게 아니라, 휴리스틱을 참고해서 리팩토링하는 게 핵심

## 생각해보자

### 어디까지가 냄새나는 코드일까?

- 긴 함수나 클래스는 언제든 나쁜 것일까?
- 프로젝트 규모나 시스템 복잡도에 따라서 “이 정도는 괜찮다”라는 기준이 달라 질텐데 잇츠는 어디 까지 괜찮은 것일까?

### 자동화 도구와 사람의 판단

- 도구가 “냄새”라고 하면 무조건 따라야 하는 것일까?
- 도구의 경고과 개발자의 판단중 어느쪽을 더 우선시 해야 하는 것일까?

### **냄새 ↔ 휴리스틱 매칭은 주관적일 수 있다**

| 코드 냄새 유형 | 관련 휴리스틱 | 적용 시 고려 포인트 |
| --- | --- | --- |
| 긴 함수 | 함수는 한 가지 일만 하라 (Single Responsibility) | 너무 세분화하면 호출 복잡도 증가 가능. 맥락 고려. |
| 중복 코드 | 중복 제거, 공통 함수로 추출 | 단순히 제거만 하면 오히려 의존성 증가 가능. 재사용성 vs 복잡도 균형. |
| 큰 클래스 | 클래스는 단일 책임만 가져야 함 | 한 클래스가 너무 커도 안 되지만, 지나치게 분리하면 관리 어려움. |
| 긴 매개변수 목록 | 매개변수 줄이기, 객체로 묶기 | 객체로 묶으면 이해 쉬워짐, 하지만 과도하게 추상화하지 않도록 주의. |
| 글로벌 상태 사용 | 상태 캡슐화, 의존성 주입 | 테스트 편리성 증가, 하지만 설계 복잡도 고려 필요. |
| 불명확한 네이밍 | 의미 있는 이름, self-documenting 코드 | 이름만으로 모든 의미 전달 어려움. 주석과 문서 보완 필요. |
| 예외 처리 부재 | 방어적 코딩, 예외 처리 | 과도한 try-catch는 코드 가독성 저하 가능. |
| 의존성 과다 | 의존성 최소화, 느슨한 결합 | 의존성 줄이면 테스트 편리, 구조 복잡해질 수 있음. |
| 긴 조건문/중첩 | 조건 분리, 전략 패턴 | 지나치게 분리하면 오히려 흐름 파악 어려움. |
| 하드코딩 값 | 상수/설정으로 분리 | 너무 많은 설정값 분리 시 관리 복잡. |

### 실무에는 어디까지 적용이 가능할까?

- 클린코드 원칙대로하면 개발속도가 느려질 가능성이 매우 높다.
- 현실적으로 어디까지 타협이 가능한가?

<aside>
💡

**[어디까지가 냄새나는 코드인가]**

**1.절대적인 기준은 없다**

- 코드 냄새는 **“잠재적 문제 신호”**일 뿐, 항상 나쁘다는 뜻은 아님.
- 같은 코드도 팀의 경험, 도메인 복잡도, 유지보수 주기에 따라 냄새일 수도 있고 아닐 수도 있음.

예:

- 연구용 PoC 코드 → 긴 함수, 중복 코드가 있어도 허용 가능
- 금융/의료 시스템 → 작은 냄새도 치명적이 될 수 있음

**2.맥락(Context)이 기준이 된다**

- 코드가 얼마나 자주 바뀌는지
- 누가 주로 유지보수하는지 (초보자? 숙련자?)
- 장애나 버그가 나면 피해가 얼마나 큰지
→ 이런 맥락을 고려해야 냄새인지 아닌지 판단 가능

**3.냄새와 비용의 균형**

- 리팩토링해서 얻는 이득 vs 드는 비용을 따져야 함
- 냄새를 고치느라 생산성이 떨어지면 그것도 문제
- 즉, “고쳤을 때 장기적으로 유지보수가 쉬워질까?”라는 질문이 핵심

**[테스트 도구와 경고와 개발자의 판단]**

**1. 도구가 우선해야 하는 경우**

- 명백한 버그 가능성: NPE, 리소스 누수, 사용하지 않는 변수 등
- 안전/보안 관련 규칙: 입력 검증, 암호화, SQL Injection 방어 등
- 코딩 컨벤션/일관성: 팀에서 합의된 스타일은 도구가 자동으로 잡아주는 게 효율적

→ 이럴 때는 도구 경고를 따르는 게 맞음.

**2. 개발자 판단이 더 중요한 경우**

- 맥락이 중요한 경우: 긴 함수지만 리팩토링하면 오히려 가독성 떨어질 때
- 성능 최적화 코드: 도구는 “복잡하다”고 경고하지만, 알고리즘적 이유가 있을 수 있음
- 도메인 특수성: 비즈니스 규칙 때문에 일부러 복잡하게 짠 경우

→ 이럴 때는 경고를 무조건 따르지 말고, “왜 그렇게 했는지” 근거를 남기는 게 중요

**3. 가장 현실적인 접근**

- 도구 경고를 무시하는 게 아니라, “1차 필터”로 사용
- 개발자는 경고를 검토 → 필요하면 무시 사유 기록 → 협의 후 유지
- 즉, 도구가 1차 판단, 개발자가 최종 판단

👉 “테스트 도구의 경고는 참고 신호일 뿐, 최종 결정권은 개발자에게 있다.”

- 단, 버그/보안과 직접 연결되는 경고는 개발자가 무시하면 안 됨.
- 나머지는 맥락 + 팀 합의가 기준.
</aside>
