# 7월 22일 클린 코드 7장

## 7장 오류처리 (Error Handling)

### 에러 vs 오류

### 에러(Error)

> 컴퓨터 시스템이나 프로그램 내부에서 발생한 문제 
시스템적으로 복구 불가능하거나, 즉시 종료가 필요한 상황
> 
- 예 : OutOfMemoryError, StackOverFlowError, 컴파일러 내부 오류 등
- 특징 : 대부분 불가, 개발자가 직접 처리하기 어려움, 시스템 수준에서 발생(OS, 런타임)

### 오류(Bug, Fault, Mistake)

> 사람이 만든 실수로 인해 코드에 존재하는 논리적 결함 또는 문제점
대부분 코드를 고치면 해결 가능한 문제
> 
- 예 : 잘못된 로직, 반복문 경계 실수, 검증하지 않은 입력
- 특징 : 프로그래머 실수로 생김, 디버깅/테스트로 잡아낼 수 있음, 논리 오류, 타입 오류, NULL 참조 등이 이에 해당

### 클린 코드 7장에서 말하는 대상은?

> 예외(Exception)나 오류(Bug)쪽 개념이 가깝다!
애플리케이션 레벨에서 발생할 수 있는 예외(Exception)와 논리적 오류(Bug)를 어떻게 “깨끗하게” 처리하고 코드의 흐름을 망치지 않도록 할 것인가에 대해서 이야기 하고 있다.
> 

### **📘 요약**

- 오류 처리는 시스템의 신뢰성과 유지보수성에 큰 영향을 미친다. 예외 흐름을 명확히 하고, 의미 있는 방식으로 처리해야 한다.
- 깨끗한 코드란 예외 상황에서도 깨끗하게 동작하는 코드다.
- 예외 처리도 로직의 일부이며, 설계의 일환으로 간주해야 한다.

### 1. 오류 처리는 중요하다.

- 소프트웨어는 오류 상황을 반드시 처리해야 하며, 오류 처리를 무시하면 시스템의 신뢰성을 잃는다.
- 네트워크 장애, 파일 시스템 오류, 외부API 문제 등 다양한 이유로 오류가 생길 수 있기 때문에 철저하게 대비 해야한다.
- 오류는 무시하거나 조용히 넘어가면 안 된다. 시스템이 조용히 실패하는 것은 최악!

### 2. 예외를 사용하자.(반환 코드보다 예외가 낫다.)

- 예외(Exception)로 처리하는 것이 더 깔끔하고 명확하다.
- 전통적인 방식인 “에러 코드 반환 → 호출자가 확인” 방식은 오류 처리를 잊거나 누락하기 쉽다.
if (result == ERROR) 같은 코드가 반복되면 가독성이 떨어지고, 실수가 많아진다.
반면, 예외는 오류 처리와 정상 로직을 분리할 수 있어서 코드 흐름이 명확해진다.

### **3. Try-Catch-Finally 문을 깨끗하게 사용하자**

- try-catch-finally 블록 안의 코드는 정상적인 로직과 명확히 분리되어야 하며, 최소한으로 작성해야 한다.
- try 블록 안에 많은 로직을 넣으면 오류 처리 범위가 커지고, 문제의 원인을 찾기 어렵다.
catch 블록에서는 의미 있는 로그를 남기고, 가능한 복구하거나 명확하게 예외를 던져야 한다.
finally 블록은 자원 정리에만 집중되어야 한다 (예: 파일 닫기, 커넥션 정리 등).

### **4. 예외에 의미를 담자**

- 예외를 던질 때는 맥락 정보와 의미 있는 메시지를 함께 제공해야 한다.
- 단순한 throw new Exception()이 아니라, 문제의 원인을 파악할 수 있도록 상세한 메시지를 작성해야 한다.
- 가능하다면 사용자 정의 예외(Custom Exception)를 만들어 상황에 맞는 예외를 표현하라.
- 예외 메시지는 개발자가 디버깅할 수 있도록 문제 상황의 “이유, 위치, 원인”을 담는 것이 좋다.

### **5. 호출자에게 책임을 명확히 하라 (정상 흐름과 예외 흐름 분리)**

- 예외를 던질 때는 누가 예외를 처리해야 할지 책임을 분명히 해야 하며, 예외가 코드 흐름을 흐리지 않게 해야 한다.
- 예외를 무작정 catch하고 끝내지 말고, 상황에 따라 상위 호출자에게 넘기거나 책임 있는 위치에서 처리해야 한다.
- 예외 흐름을 코드의 정상적인 흐름으로 오용하지 말 것.

### **6. 오류 변환 (Exception Wrapping)**

- 외부 API나 시스템이 던지는 저수준 예외는 자신의 도메인에 맞는 예외로 변환(wrapping)해서 처리하자.
- 예: SQLException을 그대로 노출하기보다는 CustomerNotFoundException과 같이 의미 있는 예외로 감싸서 던지는 게 낫다.
- 외부 시스템에 의존하지 않고, 코드가 도메인 중심으로 동작하게 만들 수 있다.
- 예외를 감쌌을 때 원래의 예외 정보도 함께 유지해야 한다 (throw new CustomException("설명", e) 식으로..)

### **7. 정의할 수 있는 예외 클래스는 정의하자**

- 예외 상황을 설명하는 도메인 중심의 예외 클래스를 정의하면 코드 가독성과 유지보수성이 높아진다.
- 고객이 존재하지 않을 때는 CustomerNotFoundException, 입력값이 유효하지 않으면 InvalidInputException처럼 만들 수 있다.
- 이 방식은 코드에서 예외 상황을 문서처럼 설명할 수 있게 해준다.
- 예외 클래스도 지나치게 많거나 계층 구조가 복잡하면 오히려 독이 될 수 있으니, 적절히 사용해야 한다.

### **8. 예외를 잡을 때는 오류를 기록하자**

- 예외를 catch할 때 로그를 남기지 않으면 디버깅이 어렵다.
- 예외를 조용히 무시하거나 아무것도 하지 않고 넘어가면 나중에 문제를 추적하기 어렵다.
- 로그에는 예외 메시지, 스택 트레이스, 발생 시점, 관련 데이터 등을 포함시키는 것이 좋다.

### **9. 예외 처리 코드도 깨끗하게**

- 예외 처리 자체가 코드 품질을 해쳐선 안 되며, 예외 처리 코드도 클린해야 한다.
- catch 블록에 비즈니스 로직을 넣거나, 로직을 중복 작성하는 경우가 많다.
- 복잡한 예외 처리 로직도 함수로 추출하고, 필요한 경우 별도의 핸들러로 위임해라.

### **10. Null을 반환하지 마라 (null 방어는 필요하나, null 남발은 피하라)**

- null은 오류의 주요 원인이므로 가능하면 반환하지 말고, Optional이나 예외로 처리하는 것이 좋다.
- null 반환은 나중에 NullPointerException으로 이어질 가능성이 크다.
- Java에서는 Optional<T>, Kotlin은 ? nullable 타입 등으로 null 대신 명시적인 처리를 유도하라.
- 외부 라이브러리나 인터페이스에서 null을 반환한다면, 철저한 방어 코딩이 필요하다.

### 대표적인 오류 유형과 출현 빈도(일반적인 통계 및 보고서)

1. Null 참조 오류 (NullPointerException, NullReferenceException)
    - 거의 모든 언어에서 가장 흔한 오류로 꼽힘.
    - Stack Overflow 개발자 설문, 여러 개발자 보고서에서 상위권 차지.
2. 논리 오류 (Logic Errors)
    - 의도한 대로 동작하지 않는 경우.
    - 테스트나 디버깅에서 가장 어려운 오류 유형 중 하나.
3. 타입 오류 (Type Errors)
    - 잘못된 타입을 다룰 때 발생. 정적 타이핑 언어에서는 컴파일 시점, 동적 언어에서는 런타임에 자주 발생.
4. 경계 조건 및 인덱스 오류 (Array Index Out of Bounds, Off-by-One Errors)
    - 배열, 리스트, 반복문 등에서 인덱스 범위를 벗어나 발생.
5. 입력값 검증 실패
    - 사용자 입력, 외부 데이터가 예상과 다를 때 생기는 오류.
6. 동시성 오류 (Race Conditions, Deadlocks)
    - 멀티스레드 환경에서 자주 발생.
7. 예외 처리 누락
    - 예상치 못한 상황에 대한 처리 부족.

### **소프트웨어 공학이 말하는 오류 처리 원칙**

- 발생해도 사용자에게 최대한 안전하게 동작하도록 설계한다.
- 오류가 심각한 경우에는 더 큰 피해를 막기 위해 즉시 중단하는 것이 낫다.
- 에러 발생 시 로그로 기록해서 디버깅이나 추후 분석 가능하게 해야한다.
- 사용자에게 적절한 알림을 제공해야한다.

**💬 그럼 방어코딩이랑은 어떤 차이?**

- 정처기에서 말하는 건 “오류를 숨기지 말고 반드시 알리라”는 사용자/시스템 안정성 중심의 원실무에서 말하는 방어코딩 최소화는, 불필요하게 남발하는 null 체크나 무조건적인 조건문 같은 과잉 방어를 줄이자는 것이다..

즉, **오류는 숨기지 말고 반드시 처리하거나 알리되, 방어코드는 “과잉이 되지 않도록 잘 설계하자”**는 의미.